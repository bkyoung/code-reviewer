package gemini

import (
	"context"
	"fmt"

	"github.com/bkyoung/code-reviewer/internal/adapter/llm"
	"github.com/bkyoung/code-reviewer/internal/domain"
	"github.com/bkyoung/code-reviewer/internal/usecase/review"
)

const providerName = "gemini"

// Client abstracts the Google Gemini HTTP client behaviour we need.
type Client interface {
	CreateReview(ctx context.Context, req Request) (llm.ProviderResponse, error)
}

// Request represents the outbound payload for the Gemini provider.
type Request struct {
	Model     string
	Prompt    string
	Seed      uint64
	MaxTokens int
}

// Provider implements the usecase Provider port.
type Provider struct {
	model  string
	client Client
}

// NewProvider constructs a Provider for the supplied model.
func NewProvider(model string, client Client) *Provider {
	return &Provider{
		model:  model,
		client: client,
	}
}

// Review sends the prompt to Gemini and translates the response.
func (p *Provider) Review(ctx context.Context, req review.ProviderRequest) (domain.Review, error) {
	if p.client == nil {
		return domain.Review{}, fmt.Errorf("gemini client missing")
	}

	response, err := p.client.CreateReview(ctx, Request{
		Model:     p.model,
		Prompt:    req.Prompt,
		Seed:      req.Seed,
		MaxTokens: req.MaxSize,
	})
	if err != nil {
		return domain.Review{}, err
	}

	return domain.Review{
		ProviderName: providerName,
		ModelName:    response.Model,
		Summary:      response.Summary,
		Findings:     response.Findings,
		TokensIn:     response.Usage.TokensIn,
		TokensOut:    response.Usage.TokensOut,
		Cost:         response.Usage.Cost,
	}, nil
}

// EstimateTokens returns an estimated token count using tiktoken.
// Gemini uses a different tokenizer, but cl100k_base is a reasonable approximation.
func (p *Provider) EstimateTokens(text string) int {
	return llm.EstimateTokens(text)
}
